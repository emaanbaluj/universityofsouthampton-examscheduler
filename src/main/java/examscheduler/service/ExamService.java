package examscheduler.service;

import examscheduler.model.Exam;
import examscheduler.repository.ExamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ExamService {

    private static final Logger logger = LoggerFactory.getLogger(ExamService.class);

    @Autowired
    private ExamRepository examRepository;

    /**
     * Creates a new Exam and saves it to the database.
     *
     * @param exam the Exam object containing the details to be saved
     * @return the saved Exam object with an autogenerated ID
     */
    public Exam createExam(Exam exam) {
        return examRepository.save(exam);
    }

    /**
     * Retrieves a specific Exam by its ID.
     *
     * @param id the ID of the exam to retrieve
     * @return an Optional containing the Exam if found, or an empty Optional if not found
     */
    public Optional<Exam> getExamById(Long id) {
        return examRepository.findById(id);
    }

    /**
     * Searches exams by faculty with partial matching (case-insensitive).
     *
     * @param faculty the partial or full name of the faculty
     * @return a list of Exam objects that match the faculty search term
     */
    public List<Exam> getExamsByFaculty(String faculty) {
        List<Exam> exams = examRepository.findExamsByFacultyContaining(faculty.trim());
        logger.info("Found {} exams for faculty: {}", exams.size(), faculty);
        return exams;
    }

    /**
     * Searches exams by title with partial matching (case-insensitive).
     *
     * @param title the partial or full title of the exam
     * @return a list of Exam objects that match the title search term
     */
    public List<Exam> getExamsByTitle(String title) {
        List<Exam> exams = examRepository.findExamsByTitleContaining(title.trim());
        logger.info("Found {} exams for title: {}", exams.size(), title);
        return exams;
    }

    /**
     * Searches exams by module name with partial matching (case-insensitive).
     *
     * @param moduleName the partial or full module name
     * @return a list of Exam objects that match the module name search term
     */
    public List<Exam> getExamsByModule(String moduleName) {
        List<Exam> exams = examRepository.findExamsByModuleNameContaining(moduleName.trim());
        logger.info("Found {} exams for moduleName: {}", exams.size(), moduleName);
        return exams;
    }

    /**
     * Retrieves all exams.
     *
     * @return a list of all Exam objects
     */
    public List<Exam> getAllExams() {
        return examRepository.findAll();
    }

    /**
     * Updates an existing Exam by its ID.
     *
     * @param id the ID of the Exam to update
     * @param examDetails the new details for the Exam
     * @return the updated Exam object, or null if the Exam is not found
     */
    public Exam updateExam(Long id, Exam examDetails) {
        Optional<Exam> optionalExam = examRepository.findById(id);
        if (optionalExam.isPresent()) {
            Exam exam = optionalExam.get();
            exam.setFaculty(examDetails.getFaculty());
            exam.setModuleName(examDetails.getModuleName());
            exam.setTitle(examDetails.getTitle());
            exam.setDate(examDetails.getDate());
            exam.setStartTime(examDetails.getStartTime());
            exam.setEndTime(examDetails.getEndTime());
            exam.setFormat(examDetails.getFormat());
            return examRepository.save(exam);
        }
        return null;
    }

    /**
     * Deletes an exam by its ID.
     *
     * @param id the ID of the Exam to delete
     */
    public void deleteExam(Long id) {
        examRepository.deleteById(id);
    }
}